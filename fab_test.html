<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<label>Text: <input id="text" style="width: 550px;"
        value="Fit And Balance (FAB) Format: an algorithm for resizing and balancing text." /></label><br />
<br>
<div>
    <label><input id="bb" type="checkbox" checked />Show Bounding Box</label><br />
    <label><input id="ebb" type="checkbox" checked />Show Effective Bounding Box</label><br />
    <label><input id="sb" type="checkbox" checked />Show Balanced Text</label><br />
</div>
<br>
<!-- <div>
    Calculated font size: <span id="fs">0</span>px<br>
    Effective Box Width: <span id="ebw">0</span>px<br>
    Phase: <span id="phase">N/A</span><br>
</div> -->
<canvas id="canvas" style="border: 1px solid black" width="660" height="350"></canvas>
<div>
    X <input id="xin" type="number" step="1" min="0" max="350" value="100" inputmode="numeric" />
    Y <input id="yin" type="number" step="1" min="0" max="350" value="100" inputmode="numeric" />
    Width <input id="widthin" type="number" step="1" min="0" max="660" value="460" inputmode="numeric" />
    Height <input id="heightin" type="number" step="1" min="0" max="350" value="150" inputmode="numeric" />
</div>

<script>
    var REGION_X = xin.valueAsNumber;
    var REGION_Y = yin.valueAsNumber;
    var REGION_WIDTH = widthin.valueAsNumber;
    var REGION_HEIGHT = heightin.valueAsNumber;

    /** @type {CanvasRenderingContext2D} */
    var ctx = canvas.getContext("2d");
    ctx.lineJoin = "round";
    ctx.textBaseline = "top";
    ctx.imageSmoothingQuality = "high";
    ctx.textRendering = "optimizeLegibility";
    // ctx.textAlign = "center"

    function drawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const drawBB = !!bb.checked;
        const drawEBB = !!ebb.checked;

        if (drawBB) {
            ctx.fillStyle = "lightblue";
            ctx.fillRect(REGION_X, REGION_Y, REGION_WIDTH, REGION_HEIGHT);
        }
        const format = formatText(text.value, REGION_WIDTH, REGION_HEIGHT);

        if (drawEBB) {
            const fontSize = format.fontSize;
            const lines = format.lines;
            const xWidth = Math.max(...lines.map(getTextWidth));
            const yHeight = lines.length * fontSize;
            ctx.fillStyle = "orange";
            ctx.fillRect(REGION_X, REGION_Y, xWidth, yHeight);
        }

        drawText(format);
    }

    text.oninput = () => drawCanvas();
    sb.oninput = () => drawCanvas();
    bb.oninput = () => drawCanvas();
    ebb.oninput = () => drawCanvas();
    xin.oninput = () => {
        REGION_X = xin.valueAsNumber;
        drawCanvas();
    };
    yin.oninput = () => {
        REGION_Y = yin.valueAsNumber;
        drawCanvas();
    };
    widthin.oninput = () => {
        REGION_WIDTH = widthin.valueAsNumber;
        drawCanvas();
    };
    heightin.oninput = () => {
        REGION_HEIGHT = heightin.valueAsNumber;
        drawCanvas();
    };

    drawCanvas();

    function formatText(str, boxWidth, boxHeight) {
        const shouldBalance = !!sb.checked;

        const MAX_LINE_WIDTH = boxWidth;
        const MAX_FONT_SIZE = boxHeight;

        const MIN_LINE_WIDTH = 1; // in pixels
        const MIN_FONT_SIZE = 1; // in pixels

        if (str === "") {
            return { lines: [], fontSize: MAX_FONT_SIZE };
        }

        const words = str.split(" ");

        /**
         * A list representing how the caption should be broken up into
         * separate lines using some formatting strategy.
         * @type {string[][]}
         */
        let linesByWord;

        /**
         * This higher-order function returns a procedure (a.k.a. a callback)
         * for determining whether a word is able to fit into the {@link linesByWord}
         * list using the given font size and box width.
         *
         * The resulting procedure HAS SIDE EFFECTS: the procedure also appends the
         * given word to a line of the {@link linesByWord} list if, but not only if,
         * it fits.
         *
         * The resulting procedure should likely be used within another function
         * that accepts a callback function such as {@link Array.prototype.every}.
         *
         * @param {number} fontSize The font size
         * @param {number} boxWidth The max width of the region
         * @returns {(word: string) => boolean} A procedure to determine if a word will fit.
         */
        function fitIntoLinesAtSize(fontSize, boxWidth) {
            return (/** @type {string} */ word) => {
                const modifiedLine = linesByWord.at(-1).concat(word).join(" ").trim();

                // checks if adding new word exceeds the last line's box width
                if (getTextWidth(modifiedLine) >= boxWidth) {
                    // check if a single word is too big to fit
                    if (getTextWidth(word) >= boxWidth) {
                        return false;
                    }

                    // create a new line
                    linesByWord.push([word]);
                    // return if we have exceeded the maximum allowed lines
                    return linesByWord.length <= maxNumberOfLines(fontSize);
                } else {
                    // add the word if it fits on the last line
                    linesByWord.at(-1).push(word);
                    return true;
                }
            };
        }

        function tryFormatAllWords(fontSize, boxWidth) {
            ctx.font = `bold ${fontSize}px Arial`;

            // set up result array of lines
            linesByWord = [[]];

            // tries to fits every word into `linesByWord`, returning whether it was successful
            return words.every(fitIntoLinesAtSize(fontSize, boxWidth));
        }

        // Setup font size range
        let lowerFontSize = MIN_FONT_SIZE - 1; // always safe
        let upperFontSize = MAX_FONT_SIZE; // possibly too large

        // Binary search through font size range
        // This determines the maximum font size that fits all the text into the region
        while (lowerFontSize !== upperFontSize) {
            // Try new middle font-size
            const currentFontSize = ~~((upperFontSize + lowerFontSize) / 2);

            const formattedAllWords = tryFormatAllWords(currentFontSize, MAX_LINE_WIDTH);

            if (formattedAllWords) {
                lowerFontSize = currentFontSize + 1;
            } else {
                upperFontSize = currentFontSize;
            }
        }

        const finalFontSize = lowerFontSize - 1;

        // check that text is a readable size, otherwise return null
        if (finalFontSize < MIN_FONT_SIZE) {
            return null;
        }

        let finalBoxWidth = MAX_LINE_WIDTH;

        if (shouldBalance) {
            // Setup max width range
            let lowerBoxWidth = MIN_LINE_WIDTH - 1; // possibly too small
            let upperBoxWidth = MAX_LINE_WIDTH; // always safe

            // Binary search through max width range
            // This determines the minimum width that optimally balances the text within the region
            while (lowerBoxWidth !== upperBoxWidth) {
                // Try new middle max width
                const currentBoxWidth = ~~((upperBoxWidth + lowerBoxWidth) / 2);

                const formattedAllWords = tryFormatAllWords(finalFontSize, currentBoxWidth);

                if (formattedAllWords) {
                    upperBoxWidth = currentBoxWidth;
                } else {
                    lowerBoxWidth = currentBoxWidth + 1;
                }
            }

            finalBoxWidth = upperBoxWidth;
        }

        // rebuild result array
        tryFormatAllWords(finalFontSize, finalBoxWidth);

        return {
            lines: linesByWord.map((line) => line.join(" ").trim()),
            fontSize: finalFontSize,
        };
    }

    function getTextWidth(str) {
        return ctx.measureText(str).width;
    }

    function maxNumberOfLines(fontSize) {
        return Math.floor(REGION_HEIGHT / fontSize);
    }

    function drawText(format) {
        const { lines, fontSize } = format;

        ctx.fillStyle = "black";
        ctx.font = `bold ${fontSize}px Arial`;

        const BOTTOM_MARGIN = 4;

        const xloc = REGION_X;
        const yloc = REGION_Y;

        for (let i = 0; i < lines.length; i++) {
            ctx.beginPath();
            ctx.fillText(lines[i], xloc, yloc + i * fontSize + 1); // draw filled texts
            ctx.closePath();
        }
    }

    function log(...args) {
        document.body.append(document.createElement("br"), ...args.map(JSON.stringify));
    }
</script>